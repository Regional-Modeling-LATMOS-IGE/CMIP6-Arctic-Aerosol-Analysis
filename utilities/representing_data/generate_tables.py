#!/usr/bin/env python3

"""
This submodule is made to generate tables to represent some of the variables of the data.
Author : GIBONI Lucas

Feel free to copy, adapt and modify it under the provided license on github.
"""

###################################
### IMPORTATIONS OF THE MODULES ###
###################################

### DATA OBJECTS AND ASSOCIATED COMPUTATION ###

import pandas as pd  # to manage the product of the search

import xarray as xr # to manage the data

import numpy as np  # to handle numpy arrays and the associated tools

### TYPE HINTS FOR FUNCTIONS ###

from numpy.typing import NDArray  # type hints for numpy

### HOMEMADE LIBRARIES ###

from utilities.tools_for_analysis.statistical_tools.spatial_average import (
    spatial_average_given_field, # to generate the spatial average of a given field for a dataset
    adapt_full_dict_for_spatial_average, # to make sure that the datasets are ready for spatial average
)

###############################
### GENERATE THE TABLES ROW ###
###############################

def compute_needed_spatial_avg_for_tables(
        key : str, 
        dataset : xr.Dataset,
        ) -> tuple[dict[str, np.float64], 
                   dict[str, np.float64], 
                   dict[str, np.float64]]: 

    """

    ---

    ### DEFINITION ###

    This function will produce the dictionaries needed to produce a pandas dataframe modeled on the one produced by Zelinka and al. (2023).
    The dimensions of the arrays found in every single table cell depend of the time dimension. Therefore, the function checks if the dataset
    has undergone a time average otherwise it raises an error.

    Reference : 

    Zelinka, M. D., Smith, C. J., Qin, Y., and Taylor, K. E.: Comparison of methods to estimate aerosol effective radiative forcings 
    in climate models, Atmos. Chem. Phys., 23, 8879–8898, https://doi.org/10.5194/acp-23-8879-2023, 2023.

    ---

    ### INPUTS ###

    KEY : STR | the key of the entry for which we do the computation

    DATASET : XR.DATASET | the dataset from which the table row will be made

    ---

    ### OUTPUTS ###

    DICT_ARI : DICTIONARY OF DICTIONARIES OF NUMPY FLOAT 64 | this dictionary holds the row for the aerosol-radiation interaction.

    DICT_ACI : DICTIONARY OF DICTIONARIES OF NUMPY FLOAT 64 | this dictionary holds the row for the aerosol-cloud interaction.

    DICT_SUM_ACI_ARI : DICTIONARY OF DICTIONARIES OF NUMPY FLOAT 64 | this dictionary holds the row for the sum of both interactions.


    ---

    """

    ### CHECK INPUT TYPE ###

    if not isinstance(key, str):

        raise TypeError("expected a string")
    
    ### COMPUTE THE ARI PART OF THE ROW ###

    ### TEST IF THE ARRAY HAS NO TIME DIMENSION ###

    ## Compute a value that will be used afterwards ##

    noncld_scat = spatial_average_given_field(field = "noncld_scat", dataset = dataset)

    ## Test the length of the size of the numpy array (need to be 1) ##

    if noncld_scat.size != 1 :

        raise ValueError("The size of the spatially averaged values needs to be one. Check if the input dataset has undergone a time average.")

    ## Compute the rest of the values ##

    noncld_abs = spatial_average_given_field(field = "noncld_abs", dataset = dataset)

    sum_ari = noncld_scat + noncld_abs

    ## Set the dictionary ##

    dict_ari = {key :
                {
        'scat' : noncld_scat,
        'abs' : noncld_abs,
        'sum' : sum_ari,
                }
    }

    ### COMPUTE THE ACI PART OF THE ROW ###
    
    ## Compute the spatial averages ##

    cld_scat = spatial_average_given_field(field = "cld_scat", dataset = dataset)

    cld_abs = spatial_average_given_field(field = "cld_abs", dataset = dataset)

    cld_amt = spatial_average_given_field(field = "cld_amt", dataset = dataset)

    sum_aci = cld_scat + cld_abs + cld_amt

    ## Set the dictionary ##
    dict_aci = { 
        key : {
        'scat' : cld_scat,
        'abs' : cld_abs,
        'cld_amt' : cld_amt,
        'sum' : sum_aci,
        }
    }

    ### COMPUTE THE ACI+ARI PART OF THE ROW ###

    ## Compute the spatial avergae ##

    sum_aci_ari = sum_aci + sum_ari

    ## Set the dictionary ##

    dict_sum_aci_ari = {
        key : {
            "ACI + ARI " : sum_aci_ari
        }
    }

    return dict_ari, dict_aci, dict_sum_aci_ari
 
########################################################################################
### CREATE A PANDAS DATAFRAME OF NEEDED SPATIAL AVERAGES TO GENERATE THE TABLE'S ROW ###
########################################################################################

def from_dict_to_dataframe_rows(
        key : str, 
        dataset : xr.Dataset,
        ) -> pd.DataFrame :

    """

    ---

    ### DEFINITION ###

    This function will take the dictionaries generated by compute_needed_spatial_avg_for_tables to produce a pandas dataframe that will correspond
    to a row of the Table 2 in Zelinka and al. (2023).

    The dimensions of the arrays found in every single table cell depend of the time dimension. Therefore, the function compute_needed_spatial_avg_for_tables
    checks if the dataset has undergone a time average otherwise it raises an error.

    Reference : 

    Zelinka, M. D., Smith, C. J., Qin, Y., and Taylor, K. E.: Comparison of methods to estimate aerosol effective radiative forcings 
    in climate models, Atmos. Chem. Phys., 23, 8879–8898, https://doi.org/10.5194/acp-23-8879-2023, 2023.

    ---

    ### INPUTS ###

    KEY : STR | the key of the entry for which we do the computation

    DATASET : XR.DATASET | the dataset from which the table row will be made

    ---

    ### OUTPUTS ###

    DATAFRAME_ROW : PD.DATAFRAME | row of the table 


    ---

    """

    ### GENERATE THE THREE DICTIONARIES FROM THE KEY AND DATASET ###

    dict_ari, dict_aci, dict_sum_aci_ari = compute_needed_spatial_avg_for_tables(key = key, dataset =  dataset)
    
    ### COMBINE THE DICTIONARIES INTO A SINGLE DATAFRAME ###

    ## Convert the dictionaries into pandas dataframes ##

    df_ari = pd.DataFrame.from_dict(dict_ari)

    df_aci = pd.DataFrame.from_dict(dict_aci)

    df_ari_plus_aci = pd.DataFrame.from_dict(dict_sum_aci_ari)

    ## Generate a dictionary structure made of the dataframes ##

    dict_to_be_dfd = {'ARI' : df_ari, 'ACI' : df_aci, '' : df_ari_plus_aci}

    ## We generate the row from this dictionary by concatenating it ##

    dataframe_row = pd.concat(dict_to_be_dfd).T # transposition to have the entry's key as an index

    return dataframe_row



#############################
### CREATE THE FULL TABLE ###
#############################

def make_full_table(dataset_dictionary : dict[str, xr.Dataset]) -> pd.DataFrame:

    """

    ---

    ### DEFINITION ###

    This function will generate Table 2 found in Zelinka and al. (2023) with the provided dataset dictionary entries.

    Reference : 

    Zelinka, M. D., Smith, C. J., Qin, Y., and Taylor, K. E.: Comparison of methods to estimate aerosol effective radiative forcings 
    in climate models, Atmos. Chem. Phys., 23, 8879–8898, https://doi.org/10.5194/acp-23-8879-2023, 2023.

    ---

    ### INPUTS ###

    DATASET_DICTIONARTY : DICT OFXR.DATASET | the dictionary of datasets from which the table will be made

    ---

    ### OUTPUTS ###

    TABLE : PANDAS DATAFRAME | the generated table


    ---

    """

    ### GENERATE THE KEYS' LIST ###

    keys_list = list(dataset_dictionary.keys())

    ### INITIALIZE THE TABLE ###

    ## Define the first key ##

    key_00 = keys_list[0]

    ## Extract the first row ##

    full_table = from_dict_to_dataframe_rows(key = key_00, dataset = dataset_dictionary[key_00])

    ### GENERATE THE REST OF THE TABLE ###

    for key in keys_list[1:] :

        row_given_key = from_dict_to_dataframe_rows(key = key, dataset = dataset_dictionary[key])

        full_table = pd.concat([full_table, row_given_key])

    ### WE SORT THE TABLE'S KEYS BY ALPHABETICAL ORDER ###

    full_table = full_table.sort_index()

    return full_table